<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<title>3DSnake</title>

	</head>
	<body>
    <script src="js/jquery.min.js"></script>
		<script src="js/three.min.js"></script>
		<script src="js/CSS3DRenderer.js"></script>
    <link rel="stylesheet" type="text/css" href="./css/snake.css">



    <div id="container">
      <div class="instructions">

      </div>
			<div class="score">
				<input id="score-pts" type="text" value="0" readonly="true"/>
			</div>

			<div class="gameover">

			</div>
			<div id="game-window">
			</div>

    	<a href="#" id="reset-button" class="btn btn-big">reset</a>
			<div class="play-pause-container">
				<div class="play-pause play"></div>
			</div>
			<div class="left-arrow-btn"></div>
    	<div class="right-arrow-btn"></div>
		</div>



		<script>

			var camera, scene, scene2, renderer, renderer2;
			var controls;

      var sideLength = 15;
      var separation = 150;
			var cubePtVolume = Math.pow(sideLength, 3);
			var numSpheres = 0, score = 0;
			var spotIds = [];
			var spheres = {};

      var timeIter = 0;
      var turningDir = null, startQuaternion, endQuaternion, turning = false;
      var selected, selectedIndex, selectedSide, selectedSpheres = {};
			var apple, applePosId;

      // switching to steer left/right vs direction arrows...
      var hoppingVec = new THREE.Vector3( 0,0,0 ),
          prevHoppingVec = new THREE.Vector3( 0,1,0),
          paused = true;

      var WIDTH = window.innerWidth;
  		var HEIGHT = window.innerHeight;
      var CAMERA_DISTANCE = 2500;
      var TIME_STEP = 0.25;

      var KEYS = {
        37: 'left',
        // 38: 'up',
        39: 'right',
        // 40: 'down',
        32: 'pause'
      };

      var DIRECTIONS = ['x', 'y', 'z'];

      var UNIT_VECS = {
        'x': new THREE.Vector3( 1,0,0 ),
        'y': new THREE.Vector3( 0,1,0 ),
        'z': new THREE.Vector3( 0,0,1 ),
        'nx': new THREE.Vector3( -1,0,0 ),
        'ny': new THREE.Vector3( 0,-1,0 ),
        'nz': new THREE.Vector3( 0,0,-1 )
      };


      var clock = new THREE.Clock();


			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 5000 );
				scene = new THREE.Scene();
				scene2 = new THREE.Scene();

				// wireframe grid
				var side = (sideLength - 1) * separation;

				var cubeGeometry = new THREE.BoxGeometry( side, side, side, sideLength, sideLength, sideLength );
				var cubeMesh = new THREE.Mesh( cubeGeometry, new THREE.MeshBasicMaterial({
					color: 0xf0f0f0,
					opacity: 0.5
				}) );
				var helper = new THREE.EdgesHelper( cubeMesh, 0xc3c3c3 );
				helper.material.linewidth = 2
				scene2.add( cubeMesh );
				scene2.add( helper );
				// var geom = new THREE.PlaneGeometry( separation, separation );
				// var mat = new THREE.MeshBasicMaterial( {
				// 	color: 0xffff00,
				// 	side: THREE.DoubleSide
				// } );
				//
				// var plane = new THREE.Mesh( geom, mat );
				// var planeEdges = new THREE.EdgesHelper( plane, 0x00ffff );
				// planeEdges.material.linewidth = 2;
				// planeEdges.position.z = side / 2;
				// scene2.add( planeEdges );

				// spheres
				var image = document.createElement( 'img' );
				image.addEventListener( 'load', function ( event ) {
  				var offset = ( ( sideLength - 1 ) * separation ) / 2;

          // Cube
					for ( var i = 0; i < cubePtVolume ; i ++ ) {
            var xi = ( i % sideLength );
  					var yi = Math.floor( ( i / sideLength ) % sideLength );
  					var zi = Math.floor( i / ( sideLength * sideLength ) );

  					if (
  						xi === sideLength - 1 || xi === 0 ||
  						yi === sideLength - 1 || yi === 0 ||
  						zi === sideLength - 1 || zi === 0
  					) {

  						var sphere = new THREE.CSS3DSprite( image.cloneNode() );
  						sphere.position.x = xi * separation - offset,
  						sphere.position.y = yi * separation - offset,
  						sphere.position.z = zi * separation - offset;
  						sphere.element.style.opacity = "0.1";
							sphere.spotId = i;
              scene.add( sphere );
							spotIds.push(i);
							numSpheres ++;

							if (sphere.position.x === 0 &&
	                sphere.position.y === 0 &&
	                sphere.position.z > 0 ) {
                selectedIndex = i;
                selected = sphere;
                selectedSpheres[sphere.spotId] = true;
                selectedSide = 'z';
                startQuaternion = endQuaternion = getEndQuaternion()
                camera.position.copy(startQuaternion);
              }

  					} else {
              sphere = null;
            }
  					spheres[i] = sphere;
					}

					// place apple after all spheres are laid out

					placeApple();

				}, false );

				// apple
				var appleImg = document.createElement( 'img' );
				appleImg.addEventListener( 'load', function ( event ) {

					apple = new THREE.CSS3DSprite( appleImg.cloneNode() );
					scene.add( apple );

					image.src = 'images/sprite.png';


				}, false);

				// appleImg.src = 'images/apple.png';
				appleImg.src = 'images/diamond.png';


        // window.addEventListener('keydown', onKeyDown, false );
				//
        $(document).keydown(onKeyDown);
				$(".play-pause-container").click( function() { turningDir = "pause"; });
				$(".left-arrow-btn").click( function() { turningDir = "left"; });
				$(".right-arrow-btn").click( function() { turningDir = "right"; });

				//HTML
		    element = document.createElement('div');
		    element.innerHTML = 'Plain text inside a div.';
		    element.className = 'three-div';

		    //CSS Object
		    div = new THREE.CSS3DObject(element);
		    div.position.x = 0;
		    div.position.y = 0;
		    div.position.z = -185;
		    div.rotation.y = Math.PI;
		    scene.add(div);

				renderer = new THREE.CSS3DRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.domElement.style.position = 'absolute';
    		renderer.domElement.style.top = 0;

				document.getElementById( 'game-window' ).appendChild( renderer.domElement );

				renderer2 = new THREE.WebGLRenderer();
				renderer2.setClearColor( 0xffffff );
				renderer2.setPixelRatio( window.devicePixelRatio );
				renderer2.setSize( window.innerWidth, window.innerHeight );
				document.getElementById( 'game-window' ).appendChild( renderer2.domElement );

				//

				// controls = new THREE.TrackballControls( camera, renderer.domElement );
				// controls.rotateSpeed = 0.5;

				//

				window.addEventListener( 'resize', onWindowResize, false );
        $("#reset-button").click(resetGame);
			}

      function resetGame() {
        Object.keys(spheres).forEach( function(i) {
					i = parseInt(i);
					var sphere = spheres[i];
          if (sphere) {
            sphere.element.style.opacity = "0.1";
            if (sphere.position.x === 0 &&
                sphere.position.y === 0 &&
                sphere.position.z > 0     ) {
              selectedIndex = i;
              selected = sphere;
              selectedSide = 'z';
              startQuaternion = endQuaternion = getEndQuaternion()
              camera.position.copy( startQuaternion );
            }
          }
        } )
        hoppingVec = new THREE.Vector3( 0,0,0 );
        prevHoppingVec = new THREE.Vector3( 0,1,0);
        paused = true;
				selectedSpheres = {};
        selectedSpheres[selected.spotId] = true;
				placeApple();
				score = 0;
				$(".instructions").css("display", "block");
				$(".play-pause").addClass("play");

      }

      function getUpCoordinate() {
        var vec = new THREE.Vector3 ( 0, 1, 0 );
        var arr = vec.applyQuaternion(camera.quaternion).toArray();
        var maxIdx = 0,
            maxValSq = 0,
            valSq,
            preString = "";
        arr.forEach( function(val, idx) {
          valSq = Math.pow(val, 2);
          if (valSq > maxValSq) {
            maxValSq = valSq;
            maxIdx = idx;
          }
        })

        if (arr[maxIdx] < 0) {
          preString = "n";
        }

        return preString + DIRECTIONS[maxIdx];
      }

      function onKeyDown(e) {
        turningDir = KEYS[e.keyCode];
        // console.log(turningDir);
      }

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer2.setSize( window.innerWidth, window.innerHeight );

			}

      // function getWorldDirArray() {
      //   var vec = new THREE.Vector3();
      //   var upVec = UNIT_VECS[getUpCoordinate()];
      //   var sideNormalVec = UNIT_VECS[selectedSide];

      //   switch (turningDir) {
      //     case 'left':
      //       vec.crossVectors ( sideNormalVec , upVec );
      //       break
      //     case 'right':
      //       vec.crossVectors ( upVec , sideNormalVec );
      //       break
      //     case 'up':
      //       vec.copy(upVec);
      //       break
      //     case 'down':
      //       vec.copy(upVec);
      //       vec.multiplyScalar(-1);
      //       break
      //   }
      //   // make sure it's a unit direction
      //   return vec.toArray();
      // }

      function updateHoppingVec() {
        var sideNormalVec = new THREE.Vector3();
        sideNormalVec.copy(UNIT_VECS[selectedSide]);
        switch (turningDir) {
          case 'left':
            hoppingVec.crossVectors ( sideNormalVec , hoppingVec );
            break
          case 'right':
            hoppingVec.crossVectors ( hoppingVec , sideNormalVec );
            break
          case 'pause':
            if (paused) {
							$(".gameover")[0].style.display = "none";
              hoppingVec.copy(prevHoppingVec);
              paused = false;
							$(".instructions").css("display", "none");
							$("#score-pts").val( score.toString() );
							$(".play-pause").removeClass("play");
            } else {
              prevHoppingVec.copy(hoppingVec);
              hoppingVec.multiplyScalar(0);
              paused = true;
							$(".instructions").css("display", "block");
							$(".play-pause").addClass("play");

            }
            break
        }
        turningDir = null;
      }

      function getNextSphere() {
        // var arr = getWorldDirArray();
        updateHoppingVec();
        // var arr = hoppingVec.toArray();
        var xi = ( selectedIndex % sideLength );
        var yi = Math.floor( ( selectedIndex / sideLength ) % sideLength );
        var zi = Math.floor( selectedIndex / ( sideLength * sideLength ) );

        if ( xi + hoppingVec.x >= sideLength ) {
          hoppingVec.copy(UNIT_VECS[selectedSide]).multiplyScalar(-1);
          selectedSide = 'x';
        } else if ( xi + hoppingVec.x < 0 ) {
          hoppingVec.copy( UNIT_VECS[selectedSide]).multiplyScalar(-1);
          selectedSide = 'nx';
        } else if ( yi + hoppingVec.x >= sideLength ) {
          hoppingVec.copy( UNIT_VECS[selectedSide]).multiplyScalar(-1);
          selectedSide = 'y';
        } else if ( yi + arr[1] < 0 ) {
          hoppingVec.copy( UNIT_VECS[selectedSide]).multiplyScalar(-1);
          selectedSide = 'ny';
        } else if ( zi + arr[2] >= sideLength ) {
          hoppingVec.copy( UNIT_VECS[selectedSide]).multiplyScalar(-1);
          selectedSide = 'z';
        } else if ( zi + arr[2] < 0 ) {
          hoppingVec.copy( UNIT_VECS[selectedSide]).multiplyScalar(-1);
          selectedSide = 'nz';
        }

        arr = hoppingVec.toArray();
        // only one element of arr is nonzero
        selectedIndex += arr[0]; // x
        selectedIndex += arr[1] * sideLength;  // y
        selectedIndex += arr[2] * sideLength * sideLength;  // z
        return spheres[ selectedIndex ];
      }

			function eatApple() {
				score++;
				$("#score-pts").val( score.toString() );
				placeApple();
			}

      function placeApple() {
				if (applePosId) {
					spheres[applePosId].element.style.display = "block";
				}
        var idx;
				do {
					idx = Math.floor( Math.random() * numSpheres );
					applePosId = spotIds[idx];
				} while ( isSelectedSphere( applePosId ) );
				apple.position.copy( spheres[applePosId].position );
				spheres[applePosId].element.style.display = "none";

      }

			function gameover() {
				$(".gameover")[0].style.display = "block";
				resetGame();
			}

			function isSelectedSphere(i) {
				return !!selectedSpheres[i];
			}

      function getEndQuaternion() {
        // var vec = new THREE.Vector3();
        // vec.copy(selected.position);
        // vec.normalize();
        // return vec.multiplyScalar( CAMERA_DISTANCE );

			}

			function animate() {

				requestAnimationFrame( animate );

        if (startQuaternion ) {
          timeIter += clock.getDelta();
    			if ( timeIter > TIME_STEP ) {
            camera.position.lerpVectors( startQuaternion, endQuaternion, 1 );
            timeIter = 0;
            // selected.element.style.opacity = "0.3";

            selected = getNextSphere();

						if ( selected &&
							   isSelectedSphere(selected.spotId) &&
								 Object.keys(selectedSpheres).length > 1 &&
								!paused
							) {
							gameover();
						}


            selected.element.style.opacity = "1";
            selectedSpheres[selected.spotId] = true;
            startQuaternion = endQuaternion;
            endQuaternion = getEndQuaternion();

						if ( isSelectedSphere(applePosId) ) {
							eatApple();
						}


          } else if (Object.keys(spheres).length > 0) {
            var alpha = timeIter / TIME_STEP;
            camera.position.lerpVectors( startQuaternion, endQuaternion, alpha );
          }

          var vec = new THREE.Vector3 ( 0, 0, 1 );
          vec.applyQuaternion(camera.quaternion);
          if ( vec.y >= 1 ) {
            camera.up.set( 0, -1, 0 );
          } else if ( vec.y <= -1 ) {
            camera.up.set( 0, 1, 0 );
          }

          camera.lookAt( new THREE.Vector3(0,0,0) )
          var time = performance.now();

  				// for ( var i = 0, l = selectedSpheres.length; i < l; i ++ ) {
          //
  				// 	var sphere = selectedSpheres[ i ];
  				// 	var scale = Math.sin( ( Math.floor( sphere.position.x ) + time ) * 0.002 ) * 0.3 + 1;
  				// 	sphere.scale.set( scale, scale, scale );
          // }

				}

				renderer.render( scene, camera );
				renderer2.render( scene2, camera );
			}

		</script>
	</body>
</html>
